#!/usr/bin/python

# Contains functions for compressing/recovering (english) text. Input to both functions
# is a generative model which predicts a probability distribution over the possible characters.

# A list of allowed characters. The model must return a map of probabilities whose domain
# consists of this list. Note that this list contains all letters, numbers, and special symbols
# so this shouldn't be at all restrictive.

character_list = [chr(i) for i in range(32,127)]

# The resolution of the encoding process, i.e. probabilities generated by the model are 
# incorporated at least to an accuracy of 1/resolution.

resolution = 1073741824;

def compress(text, model): # Returns the length of the message and a list of booleans representing the encrypted message.
	message_length = len(text)
	compressed_message = []
	bottom = 0
	top = 2*resolution
	max_val = top
	for a in text:
		probs = model.probabilities()
		current_res = top - bottom
		while current_res < resolution:
			top *= 2
			bottom *= 2
			max_val *= 2
			current_res *= 2
		temp = bottom + current_res
		for x in [i for i in character_list if ord(i) < ord(a)]:
			bottom += int(probs[x]*current_res)
		if ord(a) < 126:
			top = bottom + int(probs[a]*current_res)
		else:
			top = temp
		while bottom >= max_val // 2 or top < max_val // 2:
			if bottom >= max_val // 2:
				compressed_message.append(True) # represents a 1.
				bottom -= (max_val // 2)
				top -= (max_val // 2)
				max_val = max_val // 2
			elif top < max_val // 2:
				compressed_message.append(False) # represents a 0.
				max_val = max_val // 2
		model.next_char(a) # Tells the model what the current character is so it can update the probability distribution of the next character.
	return [message_length, compressed_message] 

def decompress(message, model);
	message_length = message[0]
	compressed_message = message[1]
	text = []
	bottom = 0
	top = 2*resolution
	max_val = top
	while len(text) < message_length:
		probs = model.probabilities()
		current_res = top - bottom
		while current_res < resolution:
			top *= 2
			bottom *= 2
			max_val *= 2
			current_res *= 2
		character_intervals = []
		val = 0
		character_intervals.append(val)
		for x in [i for i in character_list if ord(i) < 126]:
			val += int(probs[x]*max_val)
			character_intervals.append(val)
		character_intervals.append(max_val)
		determined = False
		while not determined:
			if len(compressed_message) == 0:
				return text
			if compressed_message.pop(0):
				bottom = (bottom + top) // 2
			else:
				top = (bottom + top) // 2
			intervals_lower = [a for a in character_intervals if a < top]
			intervals_upper = [a for a in character_intervals if a >= top]
			if intervals_lower[-1] <= bottom:
				next_char = character_list[len(intervals)]
				text.append(next_char)
				model.next_char(next_char)
				max_val = intervals_upper[0] - intervals_lower[-1]
				top = top - intervals_lower[-1]
				bottom = bottom - intervals_lower[-1]
				determined = True
	return text[:message_length]
